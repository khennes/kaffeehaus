[In progress]

## A simplified C-style programming language, parser, and compiler

For my final project at [Hackbright Academy](http://www.hackbrightacademy.com/), I decided to write a simple programming language called Waffle, along with a Pratt-style parser and a compiler, both coded by hand, in order to gain a better fundamental understanding of how programming languages are implemented. After considering a few different targets for compilation (assembly and LLVM, among others), I ultimately settled on[asm.js](http://www.asmjs.org/), a low-level subset of Javascript that’s in the process of being formalized by a team at Mozilla.

### Language design
Waffle is a statically typed, C-style programming language. Variable types are explicitly declared; I borrowed Go’s type declaration syntax and C’s structures and statement blocks. Waffle supports functions, recursion, loops, conditional statements, inline and multiline comments, and the following data types: integers, floats, strings, arrays, structures (objects), and booleans.

Because I wanted to focus most heavily on the processes of parsing and code generation in the four weeks I had to complete the project, and because Waffle was intended as a personal learning exercise rather than a usable scripting language, along the way I decided to make a few expedient choices when it came to defining the syntax. These include:
*   Adding a "var" keyword to denote new variable declarations
*   Using C-style statement block delimiters { and }
*   Ignoring lexical block scope during interpretation (for now). As function scope is handled implicitly during compilation (and Javascript has native block scope), I wasn't especially concerned about this, but I'll be looking to add true lexical scoping as a next step.

### Parsing
After using the [PLY](http://www.dabeaz.com/ply/ply.html) library to define my language's tokens, I opted to hand-code a parser rather than use a generator like Yacc to better understand what happens during the parsing process. I wrote an implementation of Pratt’s parsing algorithm based on [Frederic Lundh](http://effbot.org/zone/simple-top-down-parsing.htm)'s and [Douglas Crockford](http://javascript.crockford.com/tdop/tdop.html)'s Python and Javascript implementations, including Crockford’s extensions for statement parsing.

First, `main()` calls the `start_lex(filename)` function, which reads a user-specified Waffle file and slices it into tokens based on my articulated grammar, outputting a `token_stream`. In `tokenize()`, tokens are assigned to their unique symbol classes, which are dynamically generated by the`symbol(ttype, bp=0)` method; added to the `token_stack`; and registered to the global`symbol_table` dictionary. At the same time, each symbol is given a relative binding power (`bp`), based on how strongly it “attracts” the tokens to the right of it.

Next, `main()` instantiates the `Program` parent class and calls its chain of parsing methods: `stmtd()`, which calls `parse_expression()` (or `parse_statement()`) until the entire token stack is consumed, then returns an abstract syntax tree (AST). Since `parse_expression()` continues fetching tokens until it finds a token with a higher `bp` than the current operator’s, given the expression `5 + 2 * 6`, it would consume `5`, `+`, `2`, and `*`, then recognize that `*` had a higher `bp` than `+` (120 vs. 110), and continue parsing the expression to the end. In the meantime, the `advance()` helper function filters for syntactic errors, checking that the current token type is valid/expected before fetching the next one.

All operator symbols inherit a null (`nulld`), left (`leftd`), or statement (`stmtd`) denotation method from the parent class `BaseSymbol`, based on their position within an expression. “Prefix” tokens appear at the beginning of an expression and receive nulld; “infix” (regular binary operators like `+`, `-`, `%`, etc.), and “infix_r” (for right-associative tokens like `**` and the assignment operators `=`, `-=`, and `+=`) receive leftd. Finally, statements (function declarations, return, print, etc.) receive stmtd.

I took the intermediate step of coding a Python interpreter to check my work along the way. To that end,`main()` next calls the program node’s `eval()` method, which traverses the AST recursively and returns the result of the program.

## Code generation
After considering a few different compile targets for Waffle, including assembly language and LLVM, I ultimately settled on asm.js, a low-level subset of Javascript that has been recently popularized by Mozilla’s [Emscripten](https://github.com/kripken/emscripten/) project, which compiles C/C++ (via LLVM bitcode) to asm.js and executes it at up to half the speed of native C code in the browser. After validation by Firefox’s Javascript engine Spidermonkey, asm.js is run through an ahead-of-time compiler. (If an asm.js module fails to validate during type checking, the engine will bypass the AOT compiler and default to regular JIT compilation.)

One of the bigger challenges of compiling to asm.js is that it’s not yet well documented, aside from Mozilla’s [draft spec](http://asmjs.org/spec/latest/), and diving into it meant quite a bit of guesswork. Another challenge is that asm.js does not support any higher-level data structures like strings, arrays, or objects, so implementing all three of those required writing helper functions and other workarounds to store and manipulate the data in memory.

Asm.js code, which might be described as Javascript bytecode, stripped of most of its syntactic sugar and higher-level semantics, is wrapped in an asm.js module and given the directive prologue `“use asm”`; external functions written in regular JS can be passed into the module, then declared and called from inside. All data and global variables are stored in a Javascript typed array, which mimics the heap.

To start, I traversed the AST recursively through the `emit()` function called on each node and returned strings of asm.js code, which for simple programs resembles Javascript but is peppered with bitwise shifts and type coercions (`x|0` for integers and `+x` for doubles, the only number types that asm.js supports). After that, I took on recursive functions in order to understand heap manipulation and memory management using a single typed `ArrayBuffer`. The `ArrayBufferView` class is instantiated, once for each data type, to access the heap. Primitive types, global variables, and external functions are declared outside of the lexer/parser/codegen program in a separate header file ([header.py](https://github.com/khennes/waffle/blob/master/header.py)) that serves as the template for each generated .js file.

[In progress]